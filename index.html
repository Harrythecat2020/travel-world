<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WereldExplorer — ontdek de mooiste plekken per land</title>

  <!--
    Externe libs (CDN):
      - globe.gl (ThreeJS globe + polygons + points)
      - d3 (geoCentroid)
      - topojson-client (TopoJSON -> GeoJSON)
    Let op: dit is een single-file demo. Voor productie: pin versies en host assets zelf.
  -->
  <script src="https://cdn.jsdelivr.net/npm/globe.gl@2.45.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3/dist/topojson-client.min.js"></script>

  <style>
    :root{
      --bg: #06080f;
      --panel: rgba(13, 17, 27, 0.92);
      --text: #e8ecff;
      --muted: rgba(232,236,255,0.68);
      --line: rgba(255,255,255,0.12);
      --accent: #7aa8ff;
      --good: #45e6b0;
      --warn: #ffcc66;
      --bad: #ff6b7a;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius: 18px;
      --radius2: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: var(--sans); }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    /* Layout */
    #app { position: relative; width: 100%; height: 100%; overflow: hidden; }
    #globeWrap { position: absolute; inset: 0; }
    #globeViz { width: 100%; height: 100%; }

    /* Top bar */
    .topbar {
      position: absolute; top: 16px; left: 16px; right: 16px;
      display: flex; gap: 12px; align-items: center;
      pointer-events: none; z-index: 5;
    }
    .topbar .pill {
      pointer-events: auto;
      display: flex; align-items: center; gap: 10px;
      background: rgba(0,0,0,0.28);
      border: 1px solid var(--line);
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      padding: 10px 12px; border-radius: 999px;
      box-shadow: 0 10px 40px rgba(0,0,0,.25);
    }

    .brand { font-weight: 720; letter-spacing: .2px; display: flex; align-items: center; gap: 10px; user-select: none; white-space: nowrap; }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #fff, var(--accent)); box-shadow: 0 0 18px rgba(122,168,255,.6); }
    .kbd { font-family: var(--mono); font-size: 12px; opacity: .85; border: 1px solid var(--line); padding: 2px 8px; border-radius: 999px; background: rgba(255,255,255,0.06); }

    /* Side panel */
    #panel {
      position: absolute; top: 16px; bottom: 16px; right: 16px;
      width: min(520px, calc(100% - 32px));
      background: var(--panel); border: 1px solid var(--line);
      border-radius: var(--radius); box-shadow: var(--shadow);
      backdrop-filter: blur(14px); -webkit-backdrop-filter: blur(14px);
      z-index: 6; display: flex; flex-direction: column; overflow: hidden;
      transform: translateX(0); transition: transform .25s ease;
    }
    #panel.closed { transform: translateX(calc(100% + 22px)); }

    .panelHeader {
      padding: 14px 14px 10px 14px;
      display: flex; align-items: center; justify-content: space-between; gap: 10px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(to bottom, rgba(255,255,255,0.06), rgba(255,255,255,0));
    }
    .panelHeader h2 { margin: 0; font-size: 16px; letter-spacing: .2px; }

    .btnRow { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
    button, .btn {
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 9px 12px; border-radius: 12px;
      cursor: pointer; font-weight: 620; letter-spacing: .15px;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select: none;
    }
    button:hover, .btn:hover { background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.18); }
    button:active, .btn:active { transform: translateY(1px); }
    button.primary { background: rgba(122,168,255,0.18); border-color: rgba(122,168,255,0.35); }
    button.primary:hover { background: rgba(122,168,255,0.25); }
    button.danger { background: rgba(255,107,122,0.12); border-color: rgba(255,107,122,0.25); }
    button:disabled { opacity: .45; cursor: not-allowed; transform: none; }

    .panelBody { padding: 14px; overflow: auto; flex: 1; display: grid; gap: 12px; align-content: start; }
    .card { background: rgba(255,255,255,0.04); border: 1px solid var(--line); border-radius: var(--radius2); padding: 12px; }

    .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .muted { color: var(--muted); }
    .small { font-size: 12.5px; }
    .tiny { font-size: 12px; }
    .mono { font-family: var(--mono); }

    .searchRow { display: grid; gap: 10px; }
    .searchRow input {
      width: 100%;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 11px 12px; border-radius: 12px; outline: none;
    }
    .searchRow input:focus { border-color: rgba(122,168,255,0.5); box-shadow: 0 0 0 3px rgba(122,168,255,0.12); }

    .statusLine {
      display: flex; align-items: center; gap: 10px;
      padding: 9px 10px; border-radius: 12px;
      border: 1px dashed rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.12);
    }
    .spinner {
      width: 14px; height: 14px; border-radius: 999px;
      border: 2px solid rgba(255,255,255,0.22);
      border-top-color: rgba(122,168,255,0.9);
      animation: spin 0.9s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .placeList { display: grid; gap: 10px; }
    .place {
      display: grid; grid-template-columns: 88px 1fr; gap: 10px;
      padding: 10px; border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      cursor: pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
    }
    .place:hover { background: rgba(255,255,255,0.07); border-color: rgba(255,255,255,0.18); }
    .place:active { transform: translateY(1px); }

    .thumb {
      width: 88px; height: 66px; border-radius: 12px; overflow: hidden;
      border: 1px solid rgba(255,255,255,0.10);
      background: linear-gradient(135deg, rgba(122,168,255,0.18), rgba(255,255,255,0.05));
      display: grid; place-items: center;
      color: rgba(255,255,255,0.7); font-size: 12px; text-align: center; padding: 6px;
    }
    .thumb img { width: 100%; height: 100%; object-fit: cover; display: block; }

    .place h4 { margin: 0; font-size: 14px; line-height: 1.25; }
    .place p { margin: 4px 0 0 0; font-size: 12.5px; color: var(--muted); line-height: 1.35; }

    .coords {
      margin-top: 6px; font-size: 12px; color: rgba(232,236,255,0.8);
      font-family: var(--mono);
      display: flex; gap: 8px; flex-wrap: wrap; align-items: center;
    }
    .tag {
      font-size: 11px; padding: 2px 8px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.12);
      color: rgba(232,236,255,0.75);
    }

    /* Floating help */
    #help {
      position: absolute; bottom: 16px; left: 16px;
      z-index: 5; pointer-events: none;
      display: flex; gap: 10px; flex-wrap: wrap;
      max-width: min(720px, calc(100% - 32px));
    }
    #help .hint {
      pointer-events: auto;
      background: rgba(0,0,0,0.28);
      border: 1px solid var(--line);
      border-radius: 14px; padding: 10px 12px;
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,.25);
      display: flex; align-items: center; gap: 10px;
      color: rgba(232,236,255,0.88); font-size: 13px;
    }
    .hint strong { color: var(--text); }
    .hint .miniDot { width: 8px; height: 8px; border-radius: 50%; background: var(--good); box-shadow: 0 0 14px rgba(69,230,176,.45); }

    /* Small screens */
    @media (max-width: 760px){
      #panel { left: 16px; right: 16px; width: auto; }
      #panel.closed { transform: translateY(calc(100% + 22px)); }
      #panel { top: auto; height: 72vh; bottom: 16px; }
    }

    /* Clean pin (fix “rare blobs”) */
    .pin {
      width: 10px; height: 10px;
      border-radius: 999px;
      background: rgba(122,168,255,0.96);
      border: 1px solid rgba(255,255,255,0.75);
      box-shadow:
        0 0 0 3px rgba(122,168,255,0.16),
        0 0 18px rgba(122,168,255,.55);
      transform: translate(-50%, -50%);
      cursor: pointer;
      pointer-events: auto;
      position: relative;
    }
    .pin::after{
      content:"";
      position:absolute; inset:-7px;
      border-radius:999px;
      border: 1px solid rgba(122,168,255,0.18);
      animation: pulse 1.9s ease-out infinite;
    }
    @keyframes pulse{
      0%{ transform: scale(0.55); opacity: .85; }
      100%{ transform: scale(1.15); opacity: 0; }
    }
    .pin.placeholder{
      background: rgba(255,204,102,0.95);
      box-shadow: 0 0 0 3px rgba(255,204,102,0.14), 0 0 18px rgba(255,204,102,.42);
    }
    .pin.placeholder::after{
      border-color: rgba(255,204,102,0.18);
    }

    /* About (question mark) */
    #aboutBtn{
      position: absolute;
      right: 16px; bottom: 16px;
      width: 38px; height: 38px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.32);
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0,0,0,.28);
      color: rgba(232,236,255,0.92);
      font-weight: 850;
      display: grid; place-items: center;
      z-index: 20;
      pointer-events: auto;
    }
    #aboutBtn:hover{ background: rgba(255,255,255,0.08); }

    #aboutModal{
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 30;
    }
    #aboutModal.open{ display:flex; }
    #aboutCard{
      width: min(560px, 94vw);
      background: rgba(13, 17, 27, 0.94);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    #aboutCardHeader{
      padding: 14px 14px 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: linear-gradient(to bottom, rgba(255,255,255,0.06), rgba(255,255,255,0));
    }
    #aboutCardBody{
      padding: 14px;
      color: rgba(232,236,255,0.88);
      line-height: 1.55;
      font-size: 13.5px;
    }
    .aboutTitle{ font-weight: 850; letter-spacing: .2px; }
  </style>
</head>

<body>
  <div id="app">
    <div id="globeWrap">
      <div id="globeViz"></div>
    </div>

    <!-- Topbar -->
    <div class="topbar">
      <div class="pill brand">
        <span class="dot"></span>
        <span>WereldExplorer</span>
        <span class="kbd">klik land</span>
      </div>

      <div class="pill" style="margin-left:auto;">
        <button id="togglePanelBtn" class="primary" title="Paneel tonen/verbergen (P)">Paneel</button>
        <button id="randomBtn" title="Ga naar een willekeurig land (R)">Random</button>
        <button id="resetBtn" title="Terug naar wereldbeeld (0)">Reset</button>
      </div>
    </div>

    <!-- Side panel -->
    <aside id="panel">
      <div class="panelHeader">
        <div style="display:grid;gap:2px;">
          <h2 id="panelTitle">Klik op een land</h2>
          <div class="muted tiny" id="panelSubtitle">Dan laad ik automatisch 5+ mooie plekken met coördinaten.</div>
        </div>
        <div class="btnRow">
          <button id="clearPinsBtn" class="danger" title="Verwijder pins">Pins weg</button>
          <button id="copyLinkBtn" title="Kopieer deeplink naar dit land">Link</button>
        </div>
      </div>

      <div class="panelBody">
        <div class="card searchRow">
          <div class="row">
            <div>
              <div class="small" style="font-weight:700;">Zoek een land</div>
              <div class="muted tiny">Typ een naam en druk Enter.</div>
            </div>
            <div class="tag">Data: Natural Earth + Wikidata</div>
          </div>

          <input id="countrySearch" list="countryList" placeholder="Bijv. Nederland, Japan, Peru…" />
          <datalist id="countryList"></datalist>

          <div class="row">
            <!-- (FIX) Tour button is gray by default; becomes blue only when active -->
            <button id="tourBtn" title="Tour-modus (stap voor stap)">Tour-modus</button>
            <button id="tourPrevBtn" title="Vorige land" disabled>◀</button>
            <button id="tourNextBtn" title="Volgende land" disabled>▶</button>
            <button id="stopTourBtn" title="Tour uit" disabled>Stop</button>
            <span class="muted tiny" id="tourStatus" style="margin-left:auto;">Tour: uit</span>
          </div>

          <div class="muted tiny" style="line-height:1.4;">
            In tour-modus blijf je op een land staan. Gebruik <span class="kbd">◀</span>/<span class="kbd">▶</span> om handmatig te navigeren.
          </div>
        </div>

        <div class="card" id="countryMetaCard" style="display:none;">
          <div class="row">
            <div>
              <div class="small" style="font-weight:750;">Landinfo</div>
              <div class="muted tiny">Afkomstig uit Wikidata.</div>
            </div>
            <a id="countryWikidataLink" class="tiny" target="_blank" rel="noopener">Wikidata ↗</a>
          </div>
          <div style="display:grid;gap:8px;margin-top:10px;">
            <div class="row">
              <div class="muted tiny">ISO-numeric</div>
              <div class="mono tiny" id="isoNumeric">—</div>
            </div>
            <div class="row">
              <div class="muted tiny">Hoofdstad</div>
              <div class="tiny" id="capital">—</div>
            </div>
            <div class="row">
              <div class="muted tiny">Continent</div>
              <div class="tiny" id="continent">—</div>
            </div>
            <div class="row">
              <div class="muted tiny">Bevolking</div>
              <div class="tiny" id="population">—</div>
            </div>
          </div>
        </div>

        <div class="card" id="statusCard">
          <div class="statusLine" id="statusLine">
            <div class="miniDot" style="width:10px;height:10px;border-radius:50%;background:var(--warn);box-shadow:0 0 14px rgba(255,204,102,.35);"></div>
            <div class="small" id="statusText">Tip: sleep om te draaien, scroll om te zoomen.</div>
          </div>
        </div>

        <div class="card" id="placesCard" style="display:none;">
          <div class="row">
            <div>
              <div class="small" style="font-weight:750;">Mooiste plekken</div>
              <div class="muted tiny">Klik op een plek om er naartoe te vliegen.</div>
            </div>
            <div class="tag" id="placesCount">0</div>
          </div>

          <div class="placeList" id="placeList" style="margin-top:10px;"></div>

          <div class="muted tiny" style="margin-top:10px;line-height:1.4;">
            <strong>Opmerking:</strong> “mooiste” is subjectief. We laden direct één snelle plek, en vullen daarna automatisch aan met meer plekken uit Wikidata.
          </div>
        </div>

        <div class="card">
          <div class="small" style="font-weight:750;">Sneltoetsen</div>
          <div class="muted tiny" style="margin-top:6px;line-height:1.5;">
            <span class="kbd">P</span> paneel •
            <span class="kbd">R</span> random •
            <span class="kbd">0</span> reset •
            <span class="kbd">Shift</span> sneller draaien/zoomen •
            <span class="kbd">Esc</span> tour uit
          </div>
        </div>
      </div>
    </aside>

    <div id="help">
      <div class="hint">
        <span class="miniDot"></span>
        <div><strong>Klik op een land</strong> → eerst 1 snelle plek, daarna 5+ plekken met pins.</div>
      </div>
      <div class="hint">
        <div class="kbd">Shift</div>
        <div>ingedrukt houden = sneller draaien/zoomen.</div>
      </div>
    </div>

    <!-- About button -->
    <button id="aboutBtn" title="Info">?</button>

    <!-- About modal -->
    <div id="aboutModal" aria-hidden="true">
      <div id="aboutCard" role="dialog" aria-modal="true" aria-label="Info">
        <div id="aboutCardHeader">
          <div class="aboutTitle">Over WereldExplorer</div>
          <button id="aboutCloseBtn" title="Sluiten">Sluiten</button>
        </div>
        <div id="aboutCardBody">
          <div style="display:grid;gap:10px;">
            <div>
              WereldExplorer is een interactieve globe om de mooiste plekken op aarde te ontdekken.
              Klik op landen en verken locaties met exacte coördinaten.
            </div>
            <div class="card" style="margin:0;">
              <div class="small" style="font-weight:800;">Gemaakt door</div>
              <div class="muted" style="margin-top:6px;">
                Cas van der Linden &amp; Orlando Krommendijk
              </div>
            </div>
            <div class="muted tiny">
              Data: Natural Earth (landen) + Wikidata (plekken, coördinaten &amp; afbeeldingen).
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /**********************************************************************
     * WereldExplorer — single-file demo
     *
     * FIXES in deze versie (op basis van jouw feedback):
     * 1) Shift werkt écht: OrbitControls rotateSpeed/zoomSpeed worden tijdelijk verhoogd.
     * 2) Pins zien er goed uit: we gebruiken alleen strakke HTML-pins (geen 3D points “blobs”).
     * 3) Sneller gevoel: we tonen binnen ~0-3s een "snelle plek" (of placeholder), en laden de rest door.
     * 4) Tour-modus: stap-voor-stap met ◀/▶ (geen auto-doorscroll). Tour-knop is grijs tenzij actief.
     * 5) Rechts-onder: ?-knop met info + makers.
     **********************************************************************/

    // ====== Config ======
    const WORLD_ATLAS_TOPOJSON = "https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json";
    const EARTH_IMG = "https://unpkg.com/three-globe/example/img/earth-night.jpg";
    const BUMP_IMG  = "https://unpkg.com/three-globe/example/img/earth-topology.png";
    const SKY_IMG   = "https://unpkg.com/three-globe/example/img/night-sky.png";
    const WDQS = "https://query.wikidata.org/sparql";

    // Compacte set types (korter = minder kans op WDQS gedoe)
    const PRIMARY_PLACE_TYPES = [
      "Q9259",   // UNESCO
      "Q46169",  // national park
      "Q570116", // tourist attraction
      "Q473972", // protected area
      "Q8502",   // mountain
      "Q34038",  // waterfall
      "Q40080"   // beach
    ];

    // ====== UI refs ======
    const el = (id) => document.getElementById(id);

    const panel = el("panel");
    const panelTitle = el("panelTitle");
    const panelSubtitle = el("panelSubtitle");
    const statusText = el("statusText");
    const statusLine = el("statusLine");

    const placesCard = el("placesCard");
    const placesCount = el("placesCount");
    const placeList = el("placeList");

    const countrySearch = el("countrySearch");
    const countryList = el("countryList");

    const metaCard = el("countryMetaCard");
    const countryWikidataLink = el("countryWikidataLink");
    const isoNumericEl = el("isoNumeric");
    const capitalEl = el("capital");
    const continentEl = el("continent");
    const populationEl = el("population");

    const togglePanelBtn = el("togglePanelBtn");
    const randomBtn = el("randomBtn");
    const resetBtn = el("resetBtn");
    const clearPinsBtn = el("clearPinsBtn");
    const copyLinkBtn = el("copyLinkBtn");

    // Tour controls
    const tourBtn = el("tourBtn");
    const tourPrevBtn = el("tourPrevBtn");
    const tourNextBtn = el("tourNextBtn");
    const stopTourBtn = el("stopTourBtn");
    const tourStatus = el("tourStatus");

    // About
    const aboutBtn = el("aboutBtn");
    const aboutModal = el("aboutModal");
    const aboutCloseBtn = el("aboutCloseBtn");

    // ====== State ======
    let globe;
    let countriesFC = null;
    let selectedCountry = null;
    let hoveredCountry = null;

    // Abort previous loads
    let activeLoadController = null;
    let activeLoadToken = 0;

    // Shift speed state
    let isShiftDown = false;
    let baseRotateSpeed = 0.9;
    let baseZoomSpeed = 1.1;
    const SHIFT_MULT = 2.8;

    // Tour state (manual stepping)
    let tourActive = false;
    let tourList = [];
    let tourIndex = -1;

    // ====== Cache (memory + localStorage) ======
    const cache = { byIso: new Map() };
    const LS_KEY = "wereldexplorer_cache_v2";
    const LS_MAX_AGE_MS = 1000 * 60 * 60 * 24 * 14; // 14 dagen

    function safeJsonParse(s){ try { return JSON.parse(s); } catch { return null; } }
    function loadLocalCache(){
      const raw = localStorage.getItem(LS_KEY);
      const obj = safeJsonParse(raw);
      if (!obj || typeof obj !== "object") return;
      const now = Date.now();
      for (const [iso, entry] of Object.entries(obj)) {
        if (!entry || !entry.ts || (now - entry.ts) > LS_MAX_AGE_MS) continue;
        cache.byIso.set(iso, entry);
      }
    }
    function saveLocalCache(){
      // Sla compact op om storage te sparen
      const out = {};
      for (const [iso, entry] of cache.byIso.entries()) {
        out[iso] = {
          ts: entry.ts,
          countryQid: entry.countryQid,
          meta: entry.meta,
          // bewaar max 12 plekken
          places: (entry.places || []).slice(0, 12).map(p => ({
            qid: p.qid,
            label: p.label,
            desc: (p.desc || "").slice(0, 180),
            lat: p.lat, lng: p.lng,
            image: p.image || "",
            sitelinks: p.sitelinks || 0,
            wikidataUrl: p.wikidataUrl || ""
          }))
        };
      }
      try { localStorage.setItem(LS_KEY, JSON.stringify(out)); } catch {}
    }
    loadLocalCache();

    // ====== Helpers ======
    function padIso3(n) {
      const s = String(n ?? "").trim();
      if (!s) return "";
      const digits = s.replace(/[^\d]/g, "");
      if (!digits) return "";
      return digits.padStart(3, "0");
    }

    function fmtNum(x) {
      if (x == null || x === "") return "—";
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      return new Intl.NumberFormat("nl-NL").format(n);
    }

    function setStatus(kind, text) {
      statusText.textContent = text;
      const dot = statusLine.querySelector(".miniDot") || statusLine.firstElementChild;
      if (!dot) return;

      if (kind === "loading") {
        dot.style.background = "var(--accent)";
        dot.style.boxShadow = "0 0 14px rgba(122,168,255,.35)";
      } else if (kind === "ok") {
        dot.style.background = "var(--good)";
        dot.style.boxShadow = "0 0 14px rgba(69,230,176,.35)";
      } else if (kind === "warn") {
        dot.style.background = "var(--warn)";
        dot.style.boxShadow = "0 0 14px rgba(255,204,102,.35)";
      } else {
        dot.style.background = "var(--bad)";
        dot.style.boxShadow = "0 0 14px rgba(255,107,122,.30)";
      }
    }

    function showLoading(text) {
      setStatus("loading", text);
      if (!statusLine.querySelector(".spinner")) {
        const sp = document.createElement("div");
        sp.className = "spinner";
        statusLine.insertBefore(sp, statusLine.children[1] || null);
      }
    }
    function hideLoading(okText) {
      const sp = statusLine.querySelector(".spinner");
      if (sp) sp.remove();
      setStatus("ok", okText);
    }

    function parseWktPoint(wkt) {
      if (!wkt) return null;
      const m = /Point\(([-\d.]+)\s+([-\d.]+)\)/.exec(wkt);
      if (!m) return null;
      const lon = Number(m[1]);
      const lat = Number(m[2]);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
      return { lat, lon };
    }

    function qidFromUri(uri) {
      if (!uri) return "";
      const m = /\/(Q\d+)$/.exec(uri);
      return m ? m[1] : "";
    }

    function commonsImageUrl(fileUriOrName, width=520) {
      if (!fileUriOrName) return "";
      const u = String(fileUriOrName);
      if (u.includes("Special:FilePath/")) return u + `?width=${encodeURIComponent(width)}`;
      return `https://commons.wikimedia.org/wiki/Special:FilePath/${encodeURIComponent(u)}?width=${encodeURIComponent(width)}`;
    }

    function googleMapsLink(lat, lon) {
      const q = `${lat},${lon}`;
      return `https://www.google.com/maps?q=${encodeURIComponent(q)}`;
    }

    function escapeHtml(str) {
      return String(str || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function setHash(iso3) {
      const url = new URL(location.href);
      url.hash = iso3 ? `#iso=${encodeURIComponent(iso3)}` : "";
      history.replaceState(null, "", url);
    }

    function getHashIso() {
      const h = (location.hash || "").replace(/^#/, "");
      const params = new URLSearchParams(h);
      return params.get("iso") || "";
    }

    function closePanelIfMobile() {
      if (window.matchMedia("(max-width: 760px)").matches) {
        panel.classList.add("closed");
      }
    }

    // ====== WDQS (POST + retries + abort + timeout) ======
    async function wdqsQuery(sparql, { signal, timeoutMs = 12000 } = {}) {
      const maxTries = 2;

      for (let attempt = 0; attempt < maxTries; attempt++) {
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), timeoutMs);

        const abortHandler = () => ctrl.abort();
        if (signal) signal.addEventListener("abort", abortHandler, { once: true });

        try {
          const body = new URLSearchParams({ query: sparql });

          const res = await fetch(WDQS, {
            method: "POST",
            headers: {
              "Accept": "application/sparql-results+json",
              "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
            },
            body,
            signal: ctrl.signal
          });

          if (res.ok) return await res.json();

          const retryable = [429, 500, 502, 503, 504].includes(res.status);
          const text = await res.text().catch(() => "");
          if (retryable && attempt < maxTries - 1) {
            await new Promise(r => setTimeout(r, 450 * (attempt + 1)));
            continue;
          }
          throw new Error(`WDQS fout: ${res.status} ${res.statusText} ${text.slice(0, 160)}`);
        } catch (e) {
          if (e && (e.name === "AbortError" || String(e).includes("aborted"))) {
            if (signal?.aborted) throw e; // user canceled (new click)
            if (attempt < maxTries - 1) continue;
            throw new Error("Timeout bij Wikidata. Probeer opnieuw.");
          }
          throw e;
        } finally {
          clearTimeout(t);
          if (signal) signal.removeEventListener("abort", abortHandler);
        }
      }
      throw new Error("WDQS fout: onbekend");
    }

    // 1 query: countryQid + meta
    async function getCountryByIsoWithMeta(iso3, signal) {
      const sparql = `
        SELECT ?country ?capitalLabel ?continentLabel ?population ?flag WHERE {
          ?country wdt:P299 "${iso3}" .
          OPTIONAL { ?country wdt:P36 ?capital . }
          OPTIONAL { ?country wdt:P30 ?continent . }
          OPTIONAL { ?country wdt:P1082 ?population . }
          OPTIONAL { ?country wdt:P41 ?flag . }
          SERVICE wikibase:label { bd:serviceParam wikibase:language "nl,en". }
        }
        LIMIT 1
      `;
      const data = await wdqsQuery(sparql, { signal, timeoutMs: 9000 });
      const b = (data?.results?.bindings || [])[0] || {};
      const uri = b.country?.value || "";
      const countryQid = qidFromUri(uri);

      return {
        countryQid,
        meta: {
          capital: b.capitalLabel?.value || "—",
          continent: b.continentLabel?.value || "—",
          population: b.population?.value || "",
          flag: b.flag?.value || ""
        }
      };
    }

    async function queryPlaces(countryQid, {
      types = [],
      limit = 30,
      minSitelinks = 0,
      includeP131 = false
    } = {}, signal, timeoutMs = 12000) {
      const typeBlock = (types && types.length)
        ? `VALUES ?t { ${types.map(q => `wd:${q}`).join(" ")} } ?place wdt:P31/wdt:P279* ?t .`
        : "";

      const sitelinkFilter = minSitelinks > 0
        ? `FILTER(COALESCE(?sitelinks, 0) >= ${Number(minSitelinks)})`
        : "";

      const locationBlock = includeP131
        ? `{ ?place wdt:P17 ?country . } UNION { ?place wdt:P131* ?country . }`
        : `?place wdt:P17 ?country .`;

      const sparql = `
        SELECT ?place ?placeLabel ?placeDescription ?coord ?image ?sitelinks WHERE {
          BIND(wd:${countryQid} AS ?country)
          ?place wdt:P625 ?coord .
          ${locationBlock}
          ${typeBlock}

          FILTER NOT EXISTS { ?place wdt:P31 wd:Q4167836 }
          FILTER NOT EXISTS { ?place wdt:P31 wd:Q13406463 }

          OPTIONAL { ?place wdt:P18 ?image . }
          OPTIONAL { ?place wikibase:sitelinks ?sitelinks . }

          ${sitelinkFilter}
          SERVICE wikibase:label { bd:serviceParam wikibase:language "nl,en". }
        }
        ORDER BY DESC(COALESCE(?sitelinks, 0))
        LIMIT ${Number(limit)}
      `;

      const data = await wdqsQuery(sparql, { signal, timeoutMs });
      const rows = data?.results?.bindings || [];

      const seen = new Set();
      const places = [];

      for (const r of rows) {
        const placeUri = r.place?.value || "";
        const qid = qidFromUri(placeUri);
        if (!qid || seen.has(qid)) continue;

        const p = parseWktPoint(r.coord?.value);
        if (!p) continue;

        seen.add(qid);
        places.push({
          qid,
          label: r.placeLabel?.value || qid,
          desc: r.placeDescription?.value || "",
          lat: p.lat,
          lng: p.lon,
          image: r.image?.value ? commonsImageUrl(r.image.value, 560) : "",
          sitelinks: r.sitelinks?.value ? Number(r.sitelinks.value) : 0,
          wikidataUrl: placeUri
        });
      }

      return places;
    }

    // Progressive load:
    // - show placeholder instantly
    // - try 1 fast place (<= ~3s)
    // - load full list in background and update
    async function loadPlacesProgressive({ countryQid, iso3, countryName, centroid }, signal, token) {
      // (1) Immediate placeholder (so UI never feels “stuck”)
      const placeholder = {
        qid: "__placeholder__",
        label: "Bezig met laden…",
        desc: "Ik haal de mooiste plekken op (dit kan even duren afhankelijk van Wikidata).",
        lat: centroid.lat,
        lng: centroid.lng,
        image: "",
        sitelinks: 0,
        wikidataUrl: ""
      };
      renderPlaces([placeholder]);
      plotPins([placeholder]);

      // (2) Try to get 1 fast real place
      let firstShown = false;
      try {
        const fast = await queryPlaces(countryQid, {
          types: PRIMARY_PLACE_TYPES,
          limit: 1,
          minSitelinks: 1,
          includeP131: false
        }, signal, 3000);

        if (token !== activeLoadToken) return;

        if (fast && fast.length) {
          firstShown = true;
          hideLoading("1 plek geladen… ik laad de rest door.");
          panelSubtitle.textContent = "1 plek staat al klaar. Meer plekken worden toegevoegd…";
          renderPlaces(fast);
          plotPins(fast);
        }
      } catch (e) {
        // Ignore abort on quick skip
        if (e && (e.name === "AbortError" || String(e).includes("aborted"))) return;
        // If fast fails, keep placeholder; full load may still succeed.
      }

      // (3) Background full load (idle if possible)
      const runFull = async () => {
        try {
          const min = 5;

          // Step A: P17 + types
          let places = await queryPlaces(countryQid, {
            types: PRIMARY_PLACE_TYPES,
            limit: 60,
            minSitelinks: 2,
            includeP131: false
          }, signal, 12000);

          if (token !== activeLoadToken) return;

          // Step B: if still low, P17 without types (more “notable”)
          if (places.length < min) {
            const more = await queryPlaces(countryQid, {
              types: [],
              limit: 80,
              minSitelinks: 12,
              includeP131: false
            }, signal, 12000);

            const seen = new Set(places.map(p => p.qid));
            for (const m of more) if (!seen.has(m.qid)) places.push(m), seen.add(m.qid);
          }

          if (token !== activeLoadToken) return;

          // Step C: heavy fallback with P131*
          if (places.length < min) {
            const heavy = await queryPlaces(countryQid, {
              types: PRIMARY_PLACE_TYPES,
              limit: 120,
              minSitelinks: 0,
              includeP131: true
            }, signal, 15000);

            const seen = new Set(places.map(p => p.qid));
            for (const m of heavy) if (!seen.has(m.qid)) places.push(m), seen.add(m.qid);
          }

          if (token !== activeLoadToken) return;

          places = places.slice(0, Math.max(min, 5));

          // Update UI only if it improves (avoid flicker)
          if (!firstShown) hideLoading("Klaar! Klik op een plek om er naartoe te vliegen.");
          else setStatus("ok", "Meer plekken geladen.");
          panelSubtitle.textContent = "Kies een plek of zoom rond op de pins.";

          renderPlaces(places);
          plotPins(places);

          // Persist cache
          const existing = cache.byIso.get(iso3) || {};
          cache.byIso.set(iso3, { ...existing, places, ts: Date.now() });
          saveLocalCache();
        } catch (e) {
          if (e && (e.name === "AbortError" || String(e).includes("aborted"))) return;
          // Don’t overwrite firstShown success; only show warning
          setStatus("warn", "Kon niet alle plekken laden (Wikidata kan soms traag zijn). Probeer opnieuw of kies een ander land.");
          console.error(e);
        }
      };

      if ("requestIdleCallback" in window) {
        requestIdleCallback(runFull, { timeout: 1500 });
      } else {
        setTimeout(runFull, 250);
      }
    }

    // ====== UI render ======
    function renderPlaces(places) {
      placeList.innerHTML = "";
      placesCount.textContent = String(places.length);
      placesCard.style.display = places.length ? "block" : "none";

      for (const p of places) {
        const div = document.createElement("div");
        div.className = "place";

        const thumb = document.createElement("div");
        thumb.className = "thumb";
        if (p.image) {
          const img = document.createElement("img");
          img.src = p.image;
          img.alt = p.label;
          img.loading = "lazy";
          thumb.appendChild(img);
        } else {
          thumb.textContent = "Geen afbeelding";
        }

        const right = document.createElement("div");

        const h = document.createElement("h4");
        h.textContent = p.label;

        const d = document.createElement("p");
        d.textContent = p.desc || "—";

        const coords = document.createElement("div");
        coords.className = "coords";
        const lat = Number(p.lat);
        const lng = Number(p.lng);

        if (Number.isFinite(lat) && Number.isFinite(lng)) {
          const coordSpan = document.createElement("span");
          coordSpan.textContent = `lat ${lat.toFixed(5)} · lng ${lng.toFixed(5)}`;
          coords.appendChild(coordSpan);

          const maps = document.createElement("a");
          maps.href = googleMapsLink(lat.toFixed(5), lng.toFixed(5));
          maps.target = "_blank";
          maps.rel = "noopener";
          maps.textContent = "Google Maps ↗";
          maps.className = "tag";
          coords.appendChild(maps);
        }

        if (p.wikidataUrl) {
          const wd = document.createElement("a");
          wd.href = p.wikidataUrl;
          wd.target = "_blank";
          wd.rel = "noopener";
          wd.textContent = "Wikidata ↗";
          wd.className = "tag";
          coords.appendChild(wd);
        }

        right.appendChild(h);
        right.appendChild(d);
        right.appendChild(coords);

        div.appendChild(thumb);
        div.appendChild(right);

        div.addEventListener("click", () => {
          if (Number.isFinite(lat) && Number.isFinite(lng)) flyTo(lat, lng, 1.15);
        });

        placeList.appendChild(div);
      }
    }

    function renderMeta(iso3, countryQid, meta) {
      metaCard.style.display = "block";
      isoNumericEl.textContent = iso3 || "—";
      capitalEl.textContent = meta?.capital || "—";
      continentEl.textContent = meta?.continent || "—";
      populationEl.textContent = meta?.population ? fmtNum(meta.population) : "—";
      countryWikidataLink.href = `https://www.wikidata.org/wiki/${countryQid}`;
      countryWikidataLink.textContent = "Wikidata ↗";
    }

    function clearPins() {
      globe.htmlElementsData([]);
      placesCard.style.display = "none";
      placesCount.textContent = "0";
      placeList.innerHTML = "";
      setStatus("warn", "Pins verwijderd. Klik opnieuw op een land.");
    }

    // ====== Globe controls ======
    function flyTo(lat, lng, altitude=1.6, ms=900) {
      globe.pointOfView({ lat, lng, altitude }, ms);
    }

    function computeCountryCentroid(feature) {
      try {
        const c = d3.geoCentroid(feature); // [lon, lat]
        return { lng: c[0], lat: c[1] };
      } catch {
        return { lat: 0, lng: 0 };
      }
    }

    function setSelectedCountry(feature) {
      selectedCountry = feature;

      // (FIX) lagere polygon-altitudes (minder “blokkerig”)
      globe
        .polygonAltitude(d => d === selectedCountry ? 0.05 : (d === hoveredCountry ? 0.02 : 0.006))
        .polygonCapColor(d => d === selectedCountry ? "rgba(122,168,255,0.62)" : (d === hoveredCountry ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.07)"))
        .polygonSideColor(() => "rgba(0,0,0,0.18)")
        .polygonStrokeColor(d => d === selectedCountry ? "rgba(255,255,255,0.70)" : "rgba(255,255,255,0.22)");

      const name = feature?.properties?.name || "Onbekend land";
      panelTitle.textContent = name;
      panelSubtitle.textContent = "Even wachten… ik haal plekken met exacte coördinaten.";
    }

    function plotPins(places) {
      // (FIX) Geen pointsData (die gaf “rare blobs”). Alleen HTML pins.
      globe
        .htmlElementsData(places)
        .htmlLat(d => d.lat)
        .htmlLng(d => d.lng)
        .htmlAltitude(() => 0.01)
        .htmlElement(d => {
          const pin = document.createElement("div");
          pin.className = "pin" + (d.qid === "__placeholder__" ? " placeholder" : "");
          pin.title = d.label || "";
          pin.addEventListener("click", (e) => {
            e.stopPropagation();
            if (Number.isFinite(d.lat) && Number.isFinite(d.lng)) flyTo(d.lat, d.lng, 1.12, 650);
          });
          return pin;
        });
    }

    // ====== Country click (with progressive loading) ======
    async function onCountryClick(feature) {
      if (!feature) return;

      const iso3 = padIso3(feature.id);
      if (!iso3) {
        setStatus("bad", "Dit object heeft geen ISO-numeric code. Probeer een ander land.");
        return;
      }

      // Cancel previous load
      if (activeLoadController) activeLoadController.abort();
      activeLoadController = new AbortController();
      const mySignal = activeLoadController.signal;
      const myToken = ++activeLoadToken;

      setHash(iso3);
      setSelectedCountry(feature);

      const centroid = computeCountryCentroid(feature);
      flyTo(centroid.lat, centroid.lng, 1.85, 850);

      showLoading(`Laden… ${feature.properties.name}`);

      try {
        // Cache hit?
        const cached = cache.byIso.get(iso3);
        if (cached?.countryQid && cached?.meta) {
          renderMeta(iso3, cached.countryQid, cached.meta);
        }

        if (cached?.places?.length) {
          hideLoading("Gecachet resultaat geladen.");
          panelSubtitle.textContent = "Resultaat uit cache (snel).";
          renderPlaces(cached.places);
          plotPins(cached.places);
          closePanelIfMobile();
          return;
        }

        // Get countryQid+meta
        const { countryQid, meta } = await getCountryByIsoWithMeta(iso3, mySignal);
        if (!countryQid) throw new Error(`Geen Wikidata land gevonden voor ISO-numeric ${iso3}.`);

        if (myToken !== activeLoadToken) return;

        // Save meta in cache immediately (so it feels instant next time)
        cache.byIso.set(iso3, { countryQid, meta, places: [], ts: Date.now() });
        saveLocalCache();

        renderMeta(iso3, countryQid, meta);

        // Progressive places
        await loadPlacesProgressive({
          countryQid,
          iso3,
          countryName: feature.properties.name,
          centroid
        }, mySignal, myToken);

        closePanelIfMobile();
      } catch (err) {
        if (err && (err.name === "AbortError" || String(err).includes("aborted"))) return;
        const msg = (err && err.message) ? err.message : String(err);
        setStatus("bad", msg);
        panelSubtitle.textContent = "Er ging iets mis bij het ophalen van data.";
        console.error(err);
      }
    }

    // ====== Init ======
    async function init() {
      globe = Globe()(el("globeViz"))
        .globeImageUrl(EARTH_IMG)
        .bumpImageUrl(BUMP_IMG)
        .backgroundImageUrl(SKY_IMG)
        .atmosphereColor("rgba(122,168,255,0.35)")
        .atmosphereAltitude(0.22)
        .showGraticules(false)
        .onPolygonClick(onCountryClick)
        .onPolygonHover(d => {
          hoveredCountry = d || null;
          globe
            .polygonAltitude(x => x === selectedCountry ? 0.05 : (x === hoveredCountry ? 0.02 : 0.006))
            .polygonCapColor(x => x === selectedCountry ? "rgba(122,168,255,0.62)" : (x === hoveredCountry ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.07)"))
            .polygonStrokeColor(x => x === selectedCountry ? "rgba(255,255,255,0.70)" : (x === hoveredCountry ? "rgba(255,255,255,0.45)" : "rgba(255,255,255,0.22)"));
        });

      // Initial viewpoint
      globe.pointOfView({ lat: 18, lng: 10, altitude: 2.35 }, 0);

      // (FIX) Shift-to-speed: set baseline speeds
      const controls = globe.controls?.();
      if (controls) {
        // Baselines (feel free to tweak)
        baseRotateSpeed = controls.rotateSpeed ?? baseRotateSpeed;
        baseZoomSpeed = controls.zoomSpeed ?? baseZoomSpeed;
        controls.rotateSpeed = baseRotateSpeed;
        controls.zoomSpeed = baseZoomSpeed;
      }

      showLoading("Wereldkaart laden…");

      const world = await (await fetch(WORLD_ATLAS_TOPOJSON)).json();
      const countries = topojson.feature(world, world.objects.countries);
      countriesFC = countries;

      fillCountryList(countries.features);

      globe
        .polygonsData(countries.features)
        .polygonLabel(d => `
          <div style="font-family:system-ui;">
            <div style="font-weight:700;">${escapeHtml(d.properties.name)}</div>
            <div style="opacity:.85;font-size:12px;">Klik om plekken te laden</div>
          </div>
        `)
        .polygonAltitude(() => 0.006)
        .polygonCapColor(() => "rgba(255,255,255,0.07)")
        .polygonSideColor(() => "rgba(0,0,0,0.18)")
        .polygonStrokeColor(() => "rgba(255,255,255,0.22)");

      hideLoading("Klaar. Klik op een land om te beginnen!");
      panelSubtitle.textContent = "Klik op een land op de globe of zoek in het veld hierboven.";

      // Prepare tour list once
      tourList = countries.features.filter(f => padIso3(f.id)).slice();
      tourList.sort((a,b) => String(a.properties?.name||"").localeCompare(String(b.properties?.name||""), "nl"));

      // Deeplink
      const isoFromHash = getHashIso();
      if (isoFromHash) {
        const f = countries.features.find(x => padIso3(x.id) === padIso3(isoFromHash));
        if (f) await onCountryClick(f);
      }
    }

    function fillCountryList(features) {
      countryList.innerHTML = "";
      const opts = [];

      for (const f of features) {
        const name = f?.properties?.name;
        const iso3 = padIso3(f?.id);
        if (!name || !iso3) continue;
        opts.push({ name, iso3 });
      }

      opts.sort((a,b) => a.name.localeCompare(b.name, "nl"));

      for (const o of opts) {
        const opt = document.createElement("option");
        opt.value = o.name;
        opt.label = `${o.name} — ${o.iso3}`;
        countryList.appendChild(opt);
      }
    }

    function findCountryByName(name) {
      if (!countriesFC?.features?.length) return null;
      const q = String(name || "").trim().toLowerCase();
      if (!q) return null;

      let f = countriesFC.features.find(x => String(x.properties?.name || "").toLowerCase() === q);
      if (f) return f;

      f = countriesFC.features.find(x => String(x.properties?.name || "").toLowerCase().startsWith(q));
      if (f) return f;

      f = countriesFC.features.find(x => String(x.properties?.name || "").toLowerCase().includes(q));
      return f || null;
    }

    // ====== Shift speed (FIX) ======
    function applyShiftSpeed(mult) {
      const controls = globe?.controls?.();
      if (!controls) return;
      controls.rotateSpeed = (baseRotateSpeed || 0.9) * mult;
      controls.zoomSpeed = (baseZoomSpeed || 1.1) * mult;
    }

    window.addEventListener("keydown", (e) => {
      if (e.key === "Shift" && !isShiftDown) {
        isShiftDown = true;
        applyShiftSpeed(SHIFT_MULT);
      }
    });
    window.addEventListener("keyup", (e) => {
      if (e.key === "Shift") {
        isShiftDown = false;
        applyShiftSpeed(1);
      }
    });

    // ====== Tour mode (manual) ======
    function setTourActive(on) {
      tourActive = !!on;
      tourStatus.textContent = tourActive ? "Tour: aan" : "Tour: uit";

      // Button visuals
      tourBtn.classList.toggle("primary", tourActive);

      tourPrevBtn.disabled = !tourActive;
      tourNextBtn.disabled = !tourActive;
      stopTourBtn.disabled = !tourActive;

      if (!tourActive) tourIndex = -1;
    }

    function syncTourIndexToSelected() {
      if (!tourActive || !selectedCountry) return;
      const iso = padIso3(selectedCountry.id);
      const idx = tourList.findIndex(f => padIso3(f.id) === iso);
      if (idx >= 0) tourIndex = idx;
    }

    async function tourGo(delta) {
      if (!tourActive || !tourList.length) return;

      if (tourIndex < 0) {
        // start at selected if possible, else at 0
        if (selectedCountry) syncTourIndexToSelected();
        if (tourIndex < 0) tourIndex = 0;
      } else {
        tourIndex = (tourIndex + delta + tourList.length) % tourList.length;
      }

      const f = tourList[tourIndex];
      await onCountryClick(f);
    }

    // ====== Controls / events ======
    togglePanelBtn.addEventListener("click", () => panel.classList.toggle("closed"));

    randomBtn.addEventListener("click", () => {
      if (!countriesFC?.features?.length) return;
      const list = countriesFC.features.filter(f => padIso3(f.id));
      const pick = list[Math.floor(Math.random() * list.length)];
      onCountryClick(pick);
    });

    resetBtn.addEventListener("click", () => {
      setHash("");
      selectedCountry = null;
      hoveredCountry = null;

      if (activeLoadController) activeLoadController.abort();

      globe
        .polygonAltitude(() => 0.006)
        .polygonCapColor(() => "rgba(255,255,255,0.07)")
        .polygonStrokeColor(() => "rgba(255,255,255,0.22)");

      flyTo(18, 10, 2.35, 900);
      clearPins();
      metaCard.style.display = "none";
      panelTitle.textContent = "Klik op een land";
      panelSubtitle.textContent = "Dan laad ik automatisch 5+ mooie plekken met coördinaten.";
      setStatus("ok", "Terug naar wereldbeeld.");
    });

    clearPinsBtn.addEventListener("click", clearPins);

    copyLinkBtn.addEventListener("click", async () => {
      const iso = selectedCountry ? padIso3(selectedCountry.id) : "";
      const url = new URL(location.href);
      url.hash = iso ? `#iso=${encodeURIComponent(iso)}` : "";
      try {
        await navigator.clipboard.writeText(url.toString());
        setStatus("ok", "Link gekopieerd naar klembord.");
      } catch {
        setStatus("warn", "Kon niet kopiëren. Kopieer handmatig uit de adresbalk.");
      }
    });

    countrySearch.addEventListener("keydown", (e) => {
      if (e.key !== "Enter") return;
      const f = findCountryByName(countrySearch.value);
      if (f) onCountryClick(f);
      else setStatus("warn", "Land niet gevonden. Probeer een andere spelling.");
    });

    // Tour buttons
    tourBtn.addEventListener("click", () => {
      setTourActive(!tourActive);
      if (tourActive) {
        // Start on selected (if any), else first country, but do not auto-next.
        tourStatus.textContent = "Tour: aan";
        setStatus("ok", "Tour aan. Gebruik ◀/▶ om te navigeren.");
        stopTourBtn.disabled = false;
        tourPrevBtn.disabled = false;
        tourNextBtn.disabled = false;
        if (selectedCountry) syncTourIndexToSelected();
        else tourIndex = 0;
      } else {
        setStatus("ok", "Tour uit.");
      }
    });

    tourPrevBtn.addEventListener("click", () => tourGo(-1));
    tourNextBtn.addEventListener("click", () => tourGo(+1));

    stopTourBtn.addEventListener("click", () => {
      setTourActive(false);
      setStatus("ok", "Tour uit.");
    });

    // About modal
    function openAbout(){ aboutModal.classList.add("open"); aboutModal.setAttribute("aria-hidden","false"); }
    function closeAbout(){ aboutModal.classList.remove("open"); aboutModal.setAttribute("aria-hidden","true"); }
    aboutBtn.addEventListener("click", openAbout);
    aboutCloseBtn.addEventListener("click", closeAbout);
    aboutModal.addEventListener("click", (e) => { if (e.target === aboutModal) closeAbout(); });

    // Keyboard shortcuts
    window.addEventListener("keydown", (e) => {
      if (e.key === "p" || e.key === "P") panel.classList.toggle("closed");
      if (e.key === "r" || e.key === "R") randomBtn.click();
      if (e.key === "0") resetBtn.click();
      if (e.key === "Escape") {
        // close about or turn off tour
        if (aboutModal.classList.contains("open")) closeAbout();
        else if (tourActive) setTourActive(false), setStatus("ok","Tour uit.");
      }
      if (tourActive && (e.key === "ArrowRight" || e.key === "ArrowLeft")) {
        e.preventDefault();
        tourGo(e.key === "ArrowRight" ? +1 : -1);
      }
    });

    // Start
    init().catch(err => {
      console.error(err);
      setStatus("bad", "Fout bij init. Check console + netwerk (CORS).");
    });
  </script>
</body>
</html>
